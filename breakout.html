<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ブロック崩し</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }
        canvas {
            background: #eee;
            display: block;
            border: 1px solid #ccc;
        }
        #gameInfo {
            display: flex;
            justify-content: space-between;
            width: 480px; /* Canvasの幅に合わせる */
            margin-top: 10px;
            font-size: 18px;
        }
        button {
            margin-top: 10px;
            padding: 8px 16px;
            font-size: 16px;
            cursor: pointer;
        }
    </style>
</head>
<body>

    <h1>ブロック崩し</h1>
    <canvas id="gameCanvas" width="480" height="320"></canvas>
    
    <div id="gameInfo">
        <span id="stageDisplay">ステージ: 1</span>
        <span id="scoreDisplay">スコア: 0</span>
        <span id="livesDisplay">ライフ: 3</span>
    </div>

    <button id="resetProgressButton">進捗リセット</button>

    <script>
        // --- 1. 変数と定数の設定 ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // ゲーム要素の定義
        let ball = {
            x: canvas.width / 2,
            y: canvas.height - 30,
            radius: 8,
            dx: 2, // X方向の速度
            dy: -2 // Y方向の速度
        };

        let paddle = {
            height: 10,
            width: 75,
            x: (canvas.width - 75) / 2
        };

        // ブロック関連
        let brickRowCount = 3;
        let brickColumnCount = 5;
        let brickWidth = 75;
        let brickHeight = 20;
        let brickPadding = 10;
        let brickOffsetTop = 30;
        let brickOffsetLeft = 30;
        let bricks = [];

        // ゲーム状態
        let score = 0;
        let lives = 3;
        let currentStage = 1;
        const maxStage = 5; // 最大ステージ数
        let rightPressed = false;
        let leftPressed = false;

        // UI要素
        const stageDisplay = document.getElementById('stageDisplay');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const livesDisplay = document.getElementById('livesDisplay');
        const resetButton = document.getElementById('resetProgressButton');

        // 保存用キー
        const STORAGE_KEY = 'breakout_maxStage';

        // ステージごとの設定（難易度）
        const stageConfigs = [
            // ステージ1
            { ballSpeed: 2, paddleWidth: 80, bricks: [
                { r: 3, c: 5, hp: 1 }
            ]},
            // ステージ2
            { ballSpeed: 3, paddleWidth: 75, bricks: [
                { r: 4, c: 6, hp: 1 }
            ]},
            // ステージ3
            { ballSpeed: 3, paddleWidth: 75, bricks: [
                { r: 4, c: 6, hp: 2 } // 硬いブロック(hp:2)が登場
            ]},
            // ステージ4
            { ballSpeed: 4, paddleWidth: 70, bricks: [ // パドルが狭く、ボールが速く
                { r: 5, c: 7, hp: 2 }
            ]},
            // ステージ5
            { ballSpeed: 5, paddleWidth: 65, bricks: [ // 最難関
                { r: 5, c: 7, hp: 3 }
            ]}
        ];


        // --- 2. イベントリスナー ---
        document.addEventListener('keydown', keyDownHandler, false);
        document.addEventListener('keyup', keyUpHandler, false);
        document.addEventListener('mousemove', mouseMoveHandler, false);
        resetButton.addEventListener('click', resetProgress);

        function keyDownHandler(e) {
            if (e.key === 'Right' || e.key === 'ArrowRight') {
                rightPressed = true;
            } else if (e.key === 'Left' || e.key === 'ArrowLeft') {
                leftPressed = true;
            }
        }

        function keyUpHandler(e) {
            if (e.key === 'Right' || e.key === 'ArrowRight') {
                rightPressed = false;
            } else if (e.key === 'Left' || e.key === 'ArrowLeft') {
                leftPressed = false;
            }
        }

        function mouseMoveHandler(e) {
            // キャンバスの左端を基準としたマウスのX座標
            let relativeX = e.clientX - canvas.offsetLeft;
            if (relativeX > 0 && relativeX < canvas.width) {
                // パドルがキャンバスからはみ出ないように制御
                paddle.x = relativeX - paddle.width / 2;
                if (paddle.x < 0) {
                    paddle.x = 0;
                }
                if (paddle.x + paddle.width > canvas.width) {
                    paddle.x = canvas.width - paddle.width;
                }
            }
        }

        // --- 3. 描画関数 ---

        function drawBall() {
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fillStyle = '#0095DD';
            ctx.fill();
            ctx.closePath();
        }

        function drawPaddle() {
            ctx.beginPath();
            ctx.rect(paddle.x, canvas.height - paddle.height, paddle.width, paddle.height);
            ctx.fillStyle = '#0095DD';
            ctx.fill();
            ctx.closePath();
        }

        // HPに応じたブロックの色を取得
        function getBrickColor(hp) {
            switch(hp) {
                case 1: return '#DD0000'; // 赤
                case 2: return '#DDAA00'; // オレンジ
                case 3: return '#00DD00'; // 緑
                default: return '#DDDDDD'; // グレー (HP 3以上)
            }
        }

        function drawBricks() {
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    const b = bricks[c][r];
                    if (b.status === 1) { // statusが1 (壊れていない) の場合のみ描画
                        ctx.beginPath();
                        ctx.rect(b.x, b.y, brickWidth, brickHeight);
                        ctx.fillStyle = getBrickColor(b.hp);
                        ctx.fill();
                        ctx.closePath();
                    }
                }
            }
        }

        function drawUI() {
            stageDisplay.textContent = `ステージ: ${currentStage}`;
            scoreDisplay.textContent = `スコア: ${score}`;
            livesDisplay.textContent = `ライフ: ${lives}`;
        }

        // --- 4. ゲームロジック関数 ---

        // ステージデータに基づいてブロックを初期化
        function initBricks(stage) {
            const config = stageConfigs[stage - 1]; // ステージ番号は1から始まるため
            if (!config) { // 最大ステージを超えた場合
                gameClear();
                return;
            }

            // ステージ設定を適用
            brickRowCount = config.bricks[0].r;
            brickColumnCount = config.bricks[0].c;
            const baseHp = config.bricks[0].hp;
            
            // 難易度調整
            const speed = config.ballSpeed;
            ball.dx = (ball.dx > 0 ? 1 : -1) * speed;
            ball.dy = -speed; // 常に上方向から開始
            paddle.width = config.paddleWidth;

            // オフセットを再計算して中央寄せ
            const totalBricksWidth = brickColumnCount * (brickWidth + brickPadding) - brickPadding;
            brickOffsetLeft = (canvas.width - totalBricksWidth) / 2;
            const totalBricksHeight = brickRowCount * (brickHeight + brickPadding) - brickPadding;
            brickOffsetTop = 30; // 上からのマージンは固定


            bricks = [];
            for (let c = 0; c < brickColumnCount; c++) {
                bricks[c] = [];
                for (let r = 0; r < brickRowCount; r++) {
                    let brickX = (c * (brickWidth + brickPadding)) + brickOffsetLeft;
                    let brickY = (r * (brickHeight + brickPadding)) + brickOffsetTop;
                    
                    // ステージ設定に基づいてHPを設定
                    // (ここでは単純化のため、全ブロック同じHPか、ステージ設定によって変える)
                    let hp = baseHp;
                    // 例: 3の倍数の列だけHPを増やす（ステージ3以降）
                    if (stage >= 3 && c % 3 === 0) {
                        hp = Math.min(baseHp + 1, 3); // HPを1増やす (最大3)
                    }

                    bricks[c][r] = { x: brickX, y: brickY, status: 1, hp: hp };
                }
            }
        }

        // ボールとブロックの当たり判定
        function collisionDetection() {
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    const b = bricks[c][r];
                    if (b.status === 1) { // 壊れていないブロックのみ判定
                        if (
                            ball.x + ball.radius > b.x &&
                            ball.x - ball.radius < b.x + brickWidth &&
                            ball.y + ball.radius > b.y &&
                            ball.y - ball.radius < b.y + brickHeight
                        ) {
                            ball.dy = -ball.dy; // Y方向の速度を反転
                            b.hp--; // ブロックのHPを減らす
                            
                            if (b.hp === 0) {
                                b.status = 0; // HPが0になったら壊す
                                score += 10;
                            } else {
                                score += 1; // HPが残っていても少し加点
                            }

                            checkStageClear();
                        }
                    }
                }
            }
        }

        // ステージクリア判定
        function checkStageClear() {
            let allBricksBroken = true;
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    if (bricks[c][r].status === 1) {
                        allBricksBroken = false;
                        break;
                    }
                }
                if (!allBricksBroken) break;
            }

            if (allBricksBroken) {
                nextStage();
            }
        }

        // 次のステージへ
        function nextStage() {
            currentStage++;
            if (currentStage > maxStage) {
                gameClear();
            } else {
                alert(`ステージ ${currentStage - 1} クリア！\nステージ ${currentStage} に進みます。`);
                saveProgress(currentStage); // 進捗を保存
                resetBallAndPaddle();
                initBricks(currentStage); // 次のステージのブロックをセット
            }
        }

        function gameClear() {
            alert('おめでとうございます！全ステージクリアです！');
            saveProgress(1); // 進捗をリセット (または最大ステージのままにする)
            document.location.reload();
        }

        // ボールとパドルを初期位置に戻す
        function resetBallAndPaddle() {
            ball.x = canvas.width / 2;
            ball.y = canvas.height - 30;
            // 速度は現在のステージ設定を維持 (initBricksで再設定される)
            paddle.x = (canvas.width - paddle.width) / 2;
        }

        // --- 5. 進捗管理 ---
        function saveProgress(stage) {
            try {
                // 現在保存されているステージより新しい場合のみ保存
                const savedStage = parseInt(localStorage.getItem(STORAGE_KEY) || '1');
                if (stage > savedStage) {
                    localStorage.setItem(STORAGE_KEY, stage.toString());
                }
            } catch (e) {
                console.error('進捗の保存に失敗しました:', e);
            }
        }

        function loadProgress() {
            try {
                const savedStage = localStorage.getItem(STORAGE_KEY);
                if (savedStage) {
                    currentStage = parseInt(savedStage);
                    // 最大ステージを超えていないかチェック
                    if (currentStage > maxStage) {
                        currentStage = maxStage;
                    }
                } else {
                    currentStage = 1;
                }
            } catch (e) {
                console.error('進捗の読み込みに失敗しました:', e);
                currentStage = 1;
            }
        }

        function resetProgress() {
            if (confirm('本当に進捗をリセットしてステージ1から始めますか？')) {
                try {
                    localStorage.removeItem(STORAGE_KEY);
                    alert('進捗をリセットしました。');
                    document.location.reload();
                } catch (e) {
                    console.error('リセットに失敗しました:', e);
                }
            }
        }

        // --- 6. メインループ ---
        function draw() {
            // 1. 画面クリア
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 2. 描画
            drawBricks();
            drawBall();
            drawPaddle();
            drawUI();

            // 3. 当たり判定
            collisionDetection();

            // 4. ボールの移動と壁判定
            // 左右の壁
            if (ball.x + ball.dx > canvas.width - ball.radius || ball.x + ball.dx < ball.radius) {
                ball.dx = -ball.dx;
            }
            // 上の壁
            if (ball.y + ball.dy < ball.radius) {
                ball.dy = -ball.dy;
            } 
            // 下の壁 (パドル判定)
            else if (ball.y + ball.dy > canvas.height - ball.radius - paddle.height) {
                // パドルの上にいるか
                if (ball.x > paddle.x && ball.x < paddle.x + paddle.width) {
                    // パドルに当たった
                    ball.dy = -ball.dy;
                    // パドルの当たる位置で反射角を変える (オプション)
                    let deltaX = ball.x - (paddle.x + paddle.width / 2);
                    ball.dx = deltaX * 0.15; // 当たる位置に応じてX方向の速度を変える
                } 
                else if (ball.y + ball.dy > canvas.height - ball.radius) {
                    // パドルに当たらず床に落ちた
                    lives--;
                    if (lives === 0) {
                        alert('ゲームオーバー\nスコア: ' + score);
                        document.location.reload(); // ゲームをリロード
                        // (リロードすると保存されたステージから始まる)
                    } else {
                        // ライフが残っている
                        alert(`ミス！ 残りライフ: ${lives}`);
                        resetBallAndPaddle();
                    }
                }
            }
            
            // 5. パドルの移動
            if (rightPressed && paddle.x < canvas.width - paddle.width) {
                paddle.x += 7;
            } else if (leftPressed && paddle.x > 0) {
                paddle.x -= 7;
            }

            // 6. ボールの位置更新
            ball.x += ball.dx;
            ball.y += ball.dy;

            // 7. 次のフレームを要求
            requestAnimationFrame(draw);
        }

        // --- 7. ゲーム開始 ---
        function startGame() {
            loadProgress(); // 保存されたステージを読み込む
            initBricks(currentStage); // 現在のステージでブロックを初期化
            draw(); // ゲームループ開始
        }

        startGame();

    </script>
</body>
</html>